package sequences

import (
	"bufio"
	"fmt"
	"log"
	"os"
	"regexp"
	"strconv"
	"strings"

	"mosaicmfg.com/ps-postprocess/gcode"
	"mosaicmfg.com/ps-postprocess/printerscript"
)

const EOL = "\r\n"

var generatedByRegexp = regexp.MustCompile("; generated by PrusaSlicer .+( on .+)")

func handleCoolingModuleGCodeInsert(materialCoolingModulePercentage int) string {
	output := ""
	if materialCoolingModulePercentage <= 0 {
		output += "M106 P10 S0 ; disable cooling module" + EOL
	} else {
		output += "M106 P10 S" + strconv.Itoa(int((255*materialCoolingModulePercentage+50)/100)) + " ; enable cooling module" + EOL
	}
	return output
}

func convert(inpath, outpath string, scripts ParsedScripts, locals Locals) error {
	outfile, createErr := os.Create(outpath)
	if createErr != nil {
		return createErr
	}
	writer := bufio.NewWriter(outfile)

	// run through the file once for summary information
	preflightResults, err := preflight(inpath)
	if err != nil {
		return err
	}
	locals.Global["totalLayers"] = float64(preflightResults.totalLayers)
	locals.Global["totalTime"] = float64(preflightResults.totalTime)

	// keep track of current state
	inStartSequence := false
	replacedSlicedByLine := false
	positionTracker := gcode.PositionTracker{}
	temperatureTracker := gcode.TemperatureTracker{}
	// refer to locals for the first used tool in the print during
	// the start sequence, rather than always tool 0
	currentTool := preflightResults.firstToolIndex
	currentLayer := 0
	nextLayerChangeIdx := 0
	nextMaterialChangeIdx := 0
	currentCoolingModuleDutyPercent := 0
	moveToFirstLayerPointSeen := false

	// todo: any way to cheaply calculate timeElapsed?

	err = gcode.ReadByLine(inpath, func(line gcode.Command, _ int) error {
		// update current position and/or temperature
		positionTracker.TrackInstruction(line)
		temperatureTracker.TrackInstruction(line)
		if isToolChange, tool := line.IsToolChange(); isToolChange {
			currentTool = tool
		}

		output := line.Raw

		if !replacedSlicedByLine && strings.HasPrefix(line.Raw, "; generated by PrusaSlicer ") {
			// replace "generated by PrusaSlicer" with "Sliced by Canvas"
			output = generatedByRegexp.ReplaceAllString(line.Raw, "; Sliced by Canvas$1")
			replacedSlicedByLine = true
		} else if line.Raw == startPlaceholder {
			inStartSequence = true
			return nil
		} else if line.Raw == endOfStartPlaceholder {
			inStartSequence = false
			if scripts.Start != nil {
				opts := printerscript.InterpreterOptions{
					EOL:             EOL,
					TrailingNewline: false,
					Locals: locals.Prepare(currentTool, map[string]float64{
						"layer":                     0,
						"nextX":                     preflightResults.startSequenceNextPos.nextX,
						"nextY":                     preflightResults.startSequenceNextPos.nextY,
						"nextZ":                     preflightResults.startSequenceNextPos.nextZ,
						"currentPrintTemperature":   0,
						"currentBedTemperature":     float64(temperatureTracker.Bed),
						"currentChamberTemperature": float64(temperatureTracker.Chamber),
					}),
				}
				result, err := printerscript.EvaluateTree(scripts.Start, opts)
				if err != nil {
					return err
				}
				output = filterToolchangeCommands(result.Output)
			}
		} else if line.Raw == endPlaceholder && scripts.End != nil {
			opts := printerscript.InterpreterOptions{
				EOL:             EOL,
				TrailingNewline: false,
				Locals: locals.Prepare(currentTool, map[string]float64{
					"layer":                     float64(preflightResults.totalLayers),
					"currentX":                  float64(positionTracker.CurrentX),
					"currentY":                  float64(positionTracker.CurrentY),
					"currentZ":                  float64(positionTracker.CurrentZ),
					"currentPrintTemperature":   float64(temperatureTracker.Extruder),
					"currentBedTemperature":     float64(temperatureTracker.Bed),
					"currentChamberTemperature": float64(temperatureTracker.Chamber),
				}),
			}
			result, err := printerscript.EvaluateTree(scripts.End, opts)
			if err != nil {
				return err
			}
			output = filterToolchangeCommands(result.Output)
		} else if strings.HasPrefix(line.Raw, layerChangePrefix) ||
			(!moveToFirstLayerPointSeen && line.IsMoveToFirstLayerPoint()) {
			var layer int
			var layerZ float64
			var err error
			if !moveToFirstLayerPointSeen && line.IsMoveToFirstLayerPoint() {
				layer = 0
				layerZ = preflightResults.firstLayerZ
			} else {
				layer, layerZ, err = parseLayerChangePlaceholder(line.Raw)
				if err != nil {
					return err
				}
			}
			if scripts.LayerChange != nil {
				currentLayer = layer
				opts := printerscript.InterpreterOptions{
					EOL:             EOL,
					TrailingNewline: false,
					Locals: locals.Prepare(currentTool, map[string]float64{
						"layer":                     float64(currentLayer),
						"currentX":                  float64(positionTracker.CurrentX),
						"currentY":                  float64(positionTracker.CurrentY),
						"currentZ":                  float64(positionTracker.CurrentZ),
						"nextX":                     preflightResults.layerChangeNextPos[nextLayerChangeIdx].nextX,
						"nextY":                     preflightResults.layerChangeNextPos[nextLayerChangeIdx].nextY,
						"nextZ":                     layerZ,
						"currentPrintTemperature":   float64(temperatureTracker.Extruder),
						"currentBedTemperature":     float64(temperatureTracker.Bed),
						"currentChamberTemperature": float64(temperatureTracker.Chamber),
					}),
				}
				result, err := printerscript.EvaluateTree(scripts.LayerChange, opts)
				if err != nil {
					return err
				}
				output = filterToolchangeCommands(result.Output)
			}
			if scripts.Extension == "daf" {
				materialCoolingModulePercentage := scripts.CoolingModuleSpeedPercentage[currentTool]
				if layer == scripts.EnableCoolingModuleAtLayer[currentTool] {
					if currentCoolingModuleDutyPercent != materialCoolingModulePercentage {
						output += EOL + handleCoolingModuleGCodeInsert(materialCoolingModulePercentage)
						currentCoolingModuleDutyPercent = materialCoolingModulePercentage
					}
				} else if layer < scripts.EnableCoolingModuleAtLayer[currentTool] {
					if currentCoolingModuleDutyPercent != 0 {
						output += EOL + handleCoolingModuleGCodeInsert(0)
						currentCoolingModuleDutyPercent = 0
					}
				}
			}
			output += EOL + ";END OF LAYER CHANGE SEQUENCE"
			if !moveToFirstLayerPointSeen && line.IsMoveToFirstLayerPoint() {
				moveToFirstLayerPointSeen = true
				output += EOL + line.Raw
			} else {
				nextLayerChangeIdx++
			}
		} else if strings.HasPrefix(line.Raw, materialChangePrefix) {
			toTool, err := parseMaterialChangePlaceholder(line.Raw)
			if err != nil {
				return err
			}
			if scripts.MaterialChange[toTool] == nil {
				// don't output the unprocessed placeholder line
				output = fmt.Sprintf("; material change (%d)", toTool)
			} else {
				opts := printerscript.InterpreterOptions{
					EOL:             EOL,
					TrailingNewline: false,
					Locals: locals.Prepare(currentTool, map[string]float64{
						"layer":                     float64(currentLayer),
						"currentX":                  float64(positionTracker.CurrentX),
						"currentY":                  float64(positionTracker.CurrentY),
						"currentZ":                  float64(positionTracker.CurrentZ),
						"nextX":                     preflightResults.materialChangeNextPos[nextMaterialChangeIdx].nextX,
						"nextY":                     preflightResults.materialChangeNextPos[nextMaterialChangeIdx].nextY,
						"nextZ":                     preflightResults.materialChangeNextPos[nextMaterialChangeIdx].nextZ,
						"currentPrintTemperature":   float64(temperatureTracker.Extruder),
						"currentBedTemperature":     float64(temperatureTracker.Bed),
						"currentChamberTemperature": float64(temperatureTracker.Chamber),
					}),
				}
				result, err := printerscript.EvaluateTree(scripts.MaterialChange[toTool], opts)
				if err != nil {
					return err
				}
				output = filterToolchangeCommands(result.Output)
			}

			if scripts.Extension == "daf" {
				materialCoolingModulePercentage := scripts.CoolingModuleSpeedPercentage[currentTool]
				if currentLayer >= scripts.EnableCoolingModuleAtLayer[currentTool] {
					if currentCoolingModuleDutyPercent != materialCoolingModulePercentage {
						output += EOL + handleCoolingModuleGCodeInsert(materialCoolingModulePercentage)
						currentCoolingModuleDutyPercent = materialCoolingModulePercentage
					}
				} else {
					if currentCoolingModuleDutyPercent != 0 {
						output += EOL + handleCoolingModuleGCodeInsert(0)
						currentCoolingModuleDutyPercent = 0
					}
				}
			}
			nextMaterialChangeIdx++
		}
		if inStartSequence {
			return nil
		}
		if _, err := writer.WriteString(output + EOL); err != nil {
			return err
		}
		return nil
	})
	if err != nil {
		return err
	}

	if err := writer.Flush(); err != nil {
		return err
	}
	if err := outfile.Close(); err != nil {
		return err
	}

	if err := preflightResults.preheat.Save(outpath + ".preheat"); err != nil {
		return err
	}

	return nil
}

func ConvertSequences(argv []string) {
	argc := len(argv)

	if argc < 5 {
		log.Fatalln("expected 5 command-line arguments")
	}
	inPath := argv[0]                // unmodified G-code file
	outPath := argv[1]               // modified G-code file
	scriptsPath := argv[2]           // JSON-stringified scripts to swap in
	localsPath := argv[3]            // JSON-stringified locals
	perExtruderLocalsPath := argv[4] // JSON-stringified locals

	scripts, err := LoadScripts(scriptsPath)
	if err != nil {
		log.Fatalln(err)
	}

	// lex and parse scripts just once now, and re-use the parse trees when evaluating
	parsedScripts, err := scripts.Parse()
	if err != nil {
		log.Fatalln(err)
	}

	// load locals that are available in all scripts
	locals := NewLocals()
	if err := locals.LoadGlobal(localsPath); err != nil {
		log.Fatalln(err)
	}
	if err := locals.LoadPerExtruder(perExtruderLocalsPath); err != nil {
		log.Fatalln(err)
	}

	err = convert(inPath, outPath, parsedScripts, locals)
	if err != nil {
		log.Fatalln(err)
	}
}
